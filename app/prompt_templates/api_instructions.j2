API IMPLEMENTATION:
- ALWAYS use requests.get(url, headers=self.headers, ...) for ALL API calls — self.headers contains the pre-built authentication headers
- Parse JSON response and extract relevant fields
- Runs continuously with {{ periodicity }} periodicity
- Handle rate limiting and pagination

SOURCE CONFIG SCHEMA (APISourceConfig):
- location: str (API endpoint URL)
- auth_type: str (none/api_key/bearer/basic)
- api_key: Optional[str] (API key for authentication)
- api_key_header: Optional[str] (Header name for API key, default: "X-API-Key")
- bearer_token: Optional[str] (Bearer token for authentication)
- username: Optional[str] (Username for basic auth)
- password: Optional[str] (Password for basic auth)
- timeout_seconds: int (Request timeout in seconds, default: 30)
- date_field: Optional[str] (Field name for date/timestamp in API response)
- value_field: Optional[str] (Field name for the indicator value in API response)
- custom_headers: Dict[str, str] (Additional custom headers)
- query_params: Dict[str, str] (Default query parameters)

*** CRITICAL: DO NOT MODIFY fetch_historical_data() method ***
This method is already complete and handles batch fetching logic.

REQUIRED METHODS TO CUSTOMIZE:
1. fetch_date_range(start_date, end_date): Fetch specific date ranges
   - Make API calls with date parameters, always pass headers=self.headers
   - Handle response parsing and data extraction
   - Use RateLimitHandler: await self.rate_limiter.handle_rate_limit(response)

2. get_interval_seconds(): Convert periodicity to seconds
   - Return appropriate interval based on {{ periodicity }} periodicity
   - Example: 3600 for hourly, 86400 for daily

3. fetch_external_data(): Fetch current/latest data (NO MOCK DATA!)
   - For APIs: Use same logic as fetch_date_range() but for current data
   - Make real API calls, do NOT use random.uniform() or mock data
   - Return actual data from the API, not placeholder values

*** INDICATOR NAME HANDLING ***:
- Analyze DATA SAMPLE for indicator name variations
- Use flexible matching for indicators with suffixes like "(Projection)", "(Estimate)", etc.
- Example: if base_indicator in item.get('indicator', '') or item.get('indicator', '').startswith(base_indicator)
- This ensures all related data points are captured regardless of suffix variations

ERROR HANDLING - CRITICAL:
- 429 (Rate Limit): CONTINUE execution, do NOT raise exception
- 400 (Bad Request): CONTINUE execution, do NOT raise exception  
- Use RateLimitHandler to handle 429 automatically: await self.rate_limiter.handle_rate_limit(response)

JSON RESPONSE HANDLING (analyze DATA SAMPLE structure):
- Direct list: measurements = json_data (if response is [...])
- Nested data: measurements = json_data.get('data', []) or json_data.get('results', [])
- Handle both formats: if isinstance(json_data, list): measurements = json_data
- Common data keys: 'timestamp'/'time'/'date' for datetime, 'value'/'measurement' for numeric
- Date-keyed objects: If DATA SAMPLE shows structure like {"January 2011": [...], "February 2011": [...]}, iterate through .items() to get date keys and data arrays

DATE PARAMETERS:
- You MUST use the available tools to discover which URL query parameters the API supports for date filtering.
- Test each parameter family INDIVIDUALLY by making separate requests and comparing responses:
  1. Fetch with no date params (baseline)
  2. Fetch with ?from=...&to=...
  3. Fetch with ?start=...&end=...
  4. Fetch with ?startDate=...&endDate=...
  5. Fetch with ?date_from=...&date_to=...
- Compare response sizes and data ranges to identify which parameters actually filter the data.
- Use ONLY the parameter family that works. NEVER send multiple parameter families simultaneously — unknown parameters may cause the API to misinterpret the request or return wrong results.
- If no date parameters work (all responses return the same data), filter the response data in code using start_date/end_date.

*** DATE FILTERING - CRITICAL ***:
- When needed, use INCLUSIVE date filtering: start_date <= data_datetime <= end_date
- NEVER use exclusive end_date filtering that might exclude boundary data points
- Is acceptable to have data points fetched more than once, but missing some data points is not acceptable
- For year-only data: ensure start_date includes the full target year (e.g., 2020-01-01 for year 2020)
- Example: if start_date <= datetime(year, 1, 1) <= end_date (INCLUSIVE both ends)

*** DATETIME FORMAT HANDLING - CRITICAL ***:
- Use the tools to inspect the actual datetime format in the API response (e.g. "2025-01-01T00:00:00Z", "2025-01-01T00:00:00+00:00", "2025-01-01 00:00:00", etc.)
- start_date and end_date in fetch_date_range() are naive datetimes (no timezone info)
- If the API returns timezone-aware timestamps, you MUST ensure both sides of the comparison are the same kind (both naive or both aware) — mixing them causes a Python TypeError at runtime
- Parse the actual format you observe from the API response; do not guess

CRITICAL: Implement fetch_date_range(), get_interval_seconds(), and fetch_external_data() methods.
NO MOCK DATA in fetch_external_data() - use real API calls!
