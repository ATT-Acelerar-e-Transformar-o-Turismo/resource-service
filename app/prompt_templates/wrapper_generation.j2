You are a Python code generator. Customize this wrapper template for a specific data source.

INDICATOR: {{ indicator_metadata.name }} | {{ source_config.source_type }} | ID: {{ wrapper_id }}
DOMAIN: {{ indicator_metadata.domain }} > {{ indicator_metadata.subdomain }}
UNIT: {{ indicator_metadata.unit }} | SCALE: {{ indicator_metadata.scale }} | PERIODICITY: {{ indicator_metadata.periodicity }}

DATA SOURCE: {{ source_config.location }}
AUTH: {{ source_config.auth_config }}

DATA SAMPLE:
{{ data_sample }}

REQUIRED OUTPUT FORMAT:
[{"x": "YYYY-MM-DDTHH:MM:SS", "y": float_value}, ...]

CRITICAL DATETIME CONVERSION:
- YEAR-ONLY (2004, 2005): pd.to_datetime(df['col'], format='%Y')
- NEVER use pd.to_datetime() without format parameter for numeric years
- Convert to ISO 8601: .dt.strftime('%Y-%m-%dT%H:%M:%S')

*** HANDLING NON-ENGLISH DATE FORMATS (Portuguese, Spanish, French, etc.) ***:
- When DATA SAMPLE contains month names in other languages (e.g., "Janeiro de 2011", "Agosto de 2012"), use locale or manual mapping
- RECOMMENDED APPROACH: Create a month name mapping dictionary to convert to English or numeric values
- Example for Portuguese: MONTH_MAP = {"Janeiro": "January", "Fevereiro": "February", "Março": "March", "Abril": "April", "Maio": "May", "Junho": "June", "Julho": "July", "Agosto": "August", "Setembro": "September", "Outubro": "October", "Novembro": "November", "Dezembro": "December"}
- Parse pattern like "Mês de Ano" by extracting month and year, then converting: month_en = MONTH_MAP.get(month_pt); pd.to_datetime(f"{month_en} {year}", format='%B %Y')
- For date keys in JSON objects (e.g., {"Janeiro de 2011": [...], "Fevereiro de 2011": [...]}), iterate through keys and parse each date
- ALWAYS handle parsing errors gracefully - log the error and skip the data point rather than crashing

TEMPLATE:
{{ wrapper_template }}

{{ source_specific_instructions }}

REQUIREMENTS:
1. *** NEVER modify fetch_historical_data() - it uses HistoricalDataFetcher class ***
2. ONLY customize these methods based on source type:
   - CSV/XLSX: fetch_external_data() only
   - API: fetch_date_range(), get_interval_seconds(), and fetch_external_data() only
3. Replace ALL PLACEHOLDER/... with working code in the methods above
4. Use DATA SAMPLE to understand JSON/CSV/XLSX structure
5. Ensure "x" values are ISO 8601 format
6. Keep existing template structure unchanged
7. Add necessary imports/error handling
8. *** FOR APIs: NEVER raise exceptions for HTTP errors (429, 400, 500+) - return empty list instead ***
9. *** FOR APIs: NO MOCK DATA in fetch_external_data() - use real API calls with actual data ***
10. *** HANDLE INDICATOR NAME VARIATIONS: Use flexible matching for indicators with suffixes (Projection, Estimate, etc.) ***
11. *** USE INCLUSIVE DATE FILTERING: start_date <= data_datetime <= end_date (never exclude boundary points) ***

Return ONLY complete Python code, no explanations.