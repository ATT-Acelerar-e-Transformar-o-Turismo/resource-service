You are a Python code generator. Customize this wrapper template for a specific data source.

INDICATOR: {{ indicator_metadata.name }} | {{ source_config.source_type }} | ID: {{ wrapper_id }}
DOMAIN: {{ indicator_metadata.domain }} > {{ indicator_metadata.subdomain }}
UNIT: {{ indicator_metadata.unit }} | SCALE: {{ indicator_metadata.scale }} | PERIODICITY: {{ indicator_metadata.periodicity }}

DATA SOURCE: {{ source_config.location }}
AUTH: {{ source_config.auth_config }}

DATA SAMPLE:
{{ data_sample }}

REQUIRED OUTPUT FORMAT:
[{"x": "YYYY-MM-DDTHH:MM:SS", "y": float_value}, ...]

CRITICAL DATETIME CONVERSION:
- YEAR-ONLY (2004, 2005): pd.to_datetime(df['col'], format='%Y')
- NEVER use pd.to_datetime() without format parameter for numeric years
- Convert to ISO 8601: .dt.strftime('%Y-%m-%dT%H:%M:%S')

TEMPLATE:
{{ wrapper_template }}

{{ source_specific_instructions }}

REQUIREMENTS:
1. *** NEVER modify fetch_historical_data() - it uses HistoricalDataFetcher class ***
2. ONLY customize these methods based on source type:
   - CSV/XLSX: fetch_external_data() only
   - API: fetch_date_range(), get_interval_seconds(), and fetch_external_data() only
3. Replace ALL PLACEHOLDER/... with working code in the methods above
4. Use DATA SAMPLE to understand JSON/CSV/XLSX structure
5. Ensure "x" values are ISO 8601 format
6. Keep existing template structure unchanged
7. Add necessary imports/error handling
8. *** FOR APIs: NEVER raise exceptions for HTTP errors (429, 400, 500+) - return empty list instead ***
9. *** FOR APIs: NO MOCK DATA in fetch_external_data() - use real API calls with actual data ***
10. *** HANDLE INDICATOR NAME VARIATIONS: Use flexible matching for indicators with suffixes (Projection, Estimate, etc.) ***
11. *** USE INCLUSIVE DATE FILTERING: start_date <= data_datetime <= end_date (never exclude boundary points) ***

Return ONLY complete Python code, no explanations.